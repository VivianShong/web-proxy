package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"net"
	"strings"
)

func main() {
	listener, err := net.Listen("tcp", ":4000")
	if err != nil {
		log.Fatal(err)
	}
	defer listener.Close()
	
	log.Println("Proxy listening on :4000")

	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Println("Accept error:", err)
			continue
		}
		go handleConnection(conn)
	}
}

func handleConnection(clientConn net.Conn) {
	defer clientConn.Close()

	reader := bufio.NewReader(clientConn)

	// Read request line: "GET http://example.com/path HTTP/1.1"
	requestLine, err := reader.ReadString('\n')
	if err != nil {
		log.Println("Error reading request:", err)
		return
	}
	requestLine = strings.TrimSpace(requestLine)

	// Parse request line
	parts := strings.Fields(requestLine)
	if len(parts) < 3 {
		log.Println("Malformed request:", requestLine)
		return
	}

	method := parts[0]
	rawURL := parts[1]
	
	fmt.Printf("[%s] %s\n", method, rawURL)

	// Read headers
	headers := make([]string, 0)
	var host string
	
	for {
		line, err := reader.ReadString('\n')
		if err != nil {
			return
		}
		line = strings.TrimSpace(line)
		if line == "" {
			break // End of headers
		}
		
		// Extract Host header
		if strings.HasPrefix(strings.ToLower(line), "host:") {
			host = strings.TrimSpace(line[5:])
		}
		
		headers = append(headers, line)
	}

	// Handle CONNECT (HTTPS)
	if method == "CONNECT" {
		handleHTTPS(clientConn, rawURL)
		return
	}

	// Handle HTTP
	handleHTTP(clientConn, method, rawURL, host, headers)
}

func handleHTTP(clientConn net.Conn, method, rawURL, host string, headers []string) {
	// Parse URL to get path
	// rawURL is like "http://example.com/path"
	path := "/"
	if idx := strings.Index(rawURL, "://"); idx != -1 {
		rest := rawURL[idx+3:] // "example.com/path"
		if pathIdx := strings.Index(rest, "/"); pathIdx != -1 {
			path = rest[pathIdx:] // "/path"
		}
	}

	// Determine port
	targetHost := host
	if !strings.Contains(host, ":") {
		targetHost = host + ":80"
	}

	// Connect to target server
	serverConn, err := net.Dial("tcp", targetHost)
	if err != nil {
		log.Printf("Failed to connect to %s: %v", targetHost, err)
		clientConn.Write([]byte("HTTP/1.1 502 Bad Gateway\r\n\r\n"))
		return
	}
	defer serverConn.Close()

	// Build request to send to server
	// Convert: "GET http://example.com/path HTTP/1.1" → "GET /path HTTP/1.1"
	request := fmt.Sprintf("%s %s HTTP/1.1\r\n", method, path)
	for _, header := range headers {
		// Skip proxy-specific headers
		if strings.HasPrefix(strings.ToLower(header), "proxy-") {
			continue
		}
		request += header + "\r\n"
	}
	request += "\r\n"

	// Send request to server
	serverConn.Write([]byte(request))

	// Read response and forward to client
	io.Copy(clientConn, serverConn)
	
	fmt.Println("  → Done")
}

func handleHTTPS(clientConn net.Conn, target string) {
	// target is like "www.google.com:443"
	
	// Connect to target
	serverConn, err := net.Dial("tcp", target)
	if err != nil {
		log.Printf("Failed to connect to %s: %v", target, err)
		clientConn.Write([]byte("HTTP/1.1 502 Bad Gateway\r\n\r\n"))
		return
	}
	defer serverConn.Close()

	// Tell client the tunnel is established
	clientConn.Write([]byte("HTTP/1.1 200 Connection Established\r\n\r\n"))

	fmt.Println("  → TUNNEL established")

	// Bidirectional copy
	go io.Copy(serverConn, clientConn)
	io.Copy(clientConn, serverConn)
}